# Database Schema Overview – Phase 1 Redux

Phase 1 Redux narrows the schema to the security primitives that everything else will build upon. The goal is to guarantee that every write is attributable to a transaction context with consistent actor metadata, while keeping RBAC and auditing reusable for downstream domains.

## Schemas & Tables

- **app_core.roles** – canonical list of personas (`role_name`, `display_name`, flags for system/assignable).
- **app_core.users** – end users and service accounts, including metadata and lifecycle columns.
- **app_core.user_roles** – grants linking users to personas, capturing the granting actor and timestamp.
- **app_security.transaction_contexts** – one row per request/write transaction; records actor identifiers, roles, JWT snapshot, client metadata, and completion status (`committed`, `rolled_back`, `cancelled`).
- **app_security.audit_log** – immutable row-level history generated by triggers, keyed to `txn_id` so changes can be reconstructed in context.
- **app_security.api_clients** – registry of automation/instrumentation clients and their allowed roles.
- **app_security.api_tokens** – hashed API tokens tied to a user + optional API client, with revocation metadata.

## Entity Relationship Diagram

```mermaid
erDiagram
  APP_CORE_ROLES {
    text role_name PK
    text display_name
    boolean is_assignable
    boolean is_system_role
    timestamptz created_at
    uuid created_by
  }
  APP_CORE_USERS {
    uuid id PK
    citext email
    text full_name
    text default_role
    boolean is_active
    boolean is_service_account
    jsonb metadata
    timestamptz created_at
    timestamptz updated_at
  }
  APP_CORE_USER_ROLES {
    uuid user_id PK
    text role_name PK
    uuid granted_by
    timestamptz granted_at
  }
  APP_SECURITY_TRANSACTION_CONTEXTS {
    uuid txn_id PK
    uuid actor_id
    text actor_identity
    text[] actor_roles
    text[] impersonated_roles
    jsonb jwt_claims
    text client_app
    inet client_ip
    jsonb metadata
    timestamptz started_at
    timestamptz finished_at
    text finished_status
  }
  APP_SECURITY_AUDIT_LOG {
    bigint audit_id PK
    uuid txn_id FK
    text schema_name
    text table_name
    text operation
    jsonb primary_key_data
    jsonb row_before
    jsonb row_after
    uuid actor_id
    text actor_identity
    text[] actor_roles
    timestamptz performed_at
  }
  APP_SECURITY_API_CLIENTS {
    uuid id PK
    text client_identifier
    text display_name
    citext contact_email
    text[] allowed_roles
    jsonb metadata
    timestamptz created_at
    timestamptz updated_at
  }
  APP_SECURITY_API_TOKENS {
    uuid id PK
    uuid api_client_id FK
    uuid user_id FK
    text token_digest
    text token_hint
    text[] allowed_roles
    timestamptz expires_at
    timestamptz revoked_at
    uuid revoked_by
    jsonb metadata
    timestamptz created_at
    uuid created_by
  }

  APP_CORE_ROLES ||--o{ APP_CORE_USERS : "default_role"
  APP_CORE_ROLES ||--o{ APP_CORE_USER_ROLES : grants
  APP_CORE_USERS ||--o{ APP_CORE_USER_ROLES : holds
  APP_CORE_USERS ||--o{ APP_SECURITY_TRANSACTION_CONTEXTS : acts_in
  APP_SECURITY_TRANSACTION_CONTEXTS ||--o{ APP_SECURITY_AUDIT_LOG : produces
  APP_CORE_USERS ||--o{ APP_SECURITY_API_TOKENS : owns
  APP_SECURITY_API_CLIENTS ||--o{ APP_SECURITY_API_TOKENS : issues
```

## Session & Transaction Flow

1. **JWT intake** – PostgREST/PostGraphile should call `app_security.pre_request()` to project JWT claims into session GUCs like `app.actor_id`, `app.actor_identity`, and `app.roles`.
2. **Explicit context** – PostgREST automatically calls `app_security.start_transaction_context(...)` for write verbs during its pre-request hook. Other clients can call the helper directly; if they forget, the audit trigger’s call to `app_security.require_transaction_context()` will backfill the row using the current session GUCs before the first DML executes.
3. **Row mutations** – Audit triggers on `app_core.*` and `app_security.api_*` tables call `app_security.require_transaction_context()` and then capture `row_before`/`row_after` snapshots alongside the primary key diff, falling back to the context GUCs for actor attribution.
4. **Completion** – A deferrable constraint trigger (`trg_mark_transaction_committed`) stamps `finished_status='committed'` and `finished_at` at commit time. Workflows that need alternate statuses can call `app_security.finish_transaction_context(txn_id, status, reason)` before the transaction completes.

Contexts provide a stable join key (`txn_id`) that operations, support, and compliance can use to reconstruct exactly what happened during any write.

## RBAC & RLS Summary

- Database roles (`app_admin`, `app_operator`, `app_researcher`, `app_external`, `app_automation`) inherit from `app_auth` and are minted via the bootstrap migration.
- `app_security.pre_request()` and `start_transaction_context()` both normalise the effective role list into `app.roles` so RLS predicates can rely on `app_security.has_role('role_name')`.
- Policies:
  - `app_core.roles` – world-readable, but only admins can insert/update/delete.
  - `app_core.users` – admins manage all rows; non-admin access is limited to the actor’s own user record.
  - `app_core.user_roles` – admins only.
  - `app_security.api_clients` / `api_tokens` – admins only.
  - `app_security.audit_log` – admins only (via RLS) with the companion views `app_security.v_transaction_context_activity` and `app_security.v_audit_recent_activity` exposed for operational dashboards.

RLS assumes that session settings are present; if you bypass `pre_request` or `start_transaction_context`, reads may succeed but writes will fail when the audit trigger asserts the missing context.

## API Token Lifecycle

1. Create (or reuse) an `app_security.api_clients` row describing the automation caller and the roles it may impersonate.
2. Call `app_security.create_api_token(user_id, plaintext_token, allowed_roles, expires_at, metadata, client_identifier)` from an admin context.
3. Store the plaintext token securely on the caller’s side; only the SHA-256 digest + 6-character hint are retained in the database.
4. Revoke tokens via `revoked_at`/`revoked_by` or hard deletion. All mutations continue to flow through the transaction context + audit trigger pipeline.

## Next Steps for Phase 2

- Introduce new domain schemas (samples, inventory, ELN records) that reference `app_security.transaction_contexts` for provenance instead of embedding audit data ad-hoc.
- Extend `app_security.record_audit()` to support opt-in masking or column-level filters where sensitive values should not land in the audit log in plaintext.
- Build operational SQL notebooks/runbooks for tracing a `txn_id`, enumerating changes performed by a specific actor, and monitoring context usage by persona/client.
