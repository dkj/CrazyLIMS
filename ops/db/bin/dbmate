#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "${SCRIPT_DIR}/../../.." && pwd)"
cd "${REPO_ROOT}" >/dev/null

DEFAULT_DATABASE_URL="postgres://postgres:postgres@db:5432/lims?sslmode=disable"
DATABASE_URL="${DATABASE_URL:-$DEFAULT_DATABASE_URL}"
# Use absolute paths so the dbmate container can always resolve them
export DBMATE_MIGRATIONS_DIR="/db/migrations"
export DBMATE_SCHEMA_FILE="/db/schema.sql"

# Resolve the host path for the repository so bind mounts work even when this
# helper runs from inside another container (e.g. VS Code devcontainer).
HOST_REPO_ROOT="${LOCAL_WORKSPACE_FOLDER:-}"

if [[ -z "${HOST_REPO_ROOT}" ]]; then
  DEV_CONTAINER_ID="$(docker compose ps -q dev 2>/dev/null | head -n1 || true)"
  if [[ -n "${DEV_CONTAINER_ID}" ]]; then
    TEMPLATE="{{range .Mounts}}{{if eq .Destination \"${REPO_ROOT}\"}}{{.Source}}{{end}}{{end}}"
    HOST_REPO_ROOT="$(docker inspect -f "${TEMPLATE}" "${DEV_CONTAINER_ID}" 2>/dev/null || true)"

    if [[ -z "${HOST_REPO_ROOT}" ]]; then
      FALLBACK_TEMPLATE='{{range .Mounts}}{{if eq .Destination "/workspace"}}{{.Source}}{{end}}{{end}}'
      FALLBACK_SOURCE="$(docker inspect -f "${FALLBACK_TEMPLATE}" "${DEV_CONTAINER_ID}" 2>/dev/null || true)"
      if [[ -n "${FALLBACK_SOURCE}" && "${REPO_ROOT}" == /workspace* ]]; then
        RELATIVE_PATH="${REPO_ROOT#/workspace}"
        HOST_REPO_ROOT="${FALLBACK_SOURCE}${RELATIVE_PATH}"
      fi
    fi
  fi
fi

HOST_REPO_ROOT="${HOST_REPO_ROOT:-$REPO_ROOT}"

if [[ ! -d ops/db/migrations ]]; then
  echo "Expected ops/db/migrations directory not found" >&2
  exit 1
fi

exec docker compose run --rm \
  -e "DATABASE_URL=${DATABASE_URL}" \
  -e "DBMATE_MIGRATIONS_DIR=${DBMATE_MIGRATIONS_DIR}" \
  -e "DBMATE_SCHEMA_FILE=${DBMATE_SCHEMA_FILE}" \
  -v "${HOST_REPO_ROOT}/ops/db:/db" \
  --workdir /db \
  dbmate "$@"
